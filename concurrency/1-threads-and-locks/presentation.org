# -*- mode: org -*-
#+STARTUP: showall

* Threads, Blocking, and Locks
  Basic concurrency building blocks that everything uses, somehow.

** Threads
   Basic units of executing code.

*** What is a Thread?
    A =Thread= is a thread of execution. It has its own stack, context, and position in a program.

    #+BEGIN_SRC scala
      var continue = true
      new Thread(() => {
        println("Thread started")
        while(continue) { Thread.sleep(10) }
        print("Thread done")
      }).start()
      println("Started")
    #+END_SRC

*** What does a thread cost?
    - Default for 64-bit JVM is 1MB. 
    - Can be set with =-XssNNN= JVM argument

*** How to make a thread
    #+BEGIN_SRC scala
      // Extend it! -- Don't do this
      new Thread {
        override def run(): Unit = {
          // implementation goes here
        }
      }

      // Give it a java.lang.Runnable -- Do this
      val task = new Runnable {
        override def run(): Unit = {
          // implementation goes here
        }
      }
      new Thread(task)

      // And with Java 8 goodness
      new Thread(() => {
        // implementation goes here
      })
    #+END_SRC

    None of these examples are started/running, but they're ready
 
*** Java Specifics
    - ~Daemon threads~
    - ~Uncaught exception handling~
    
** Blocking
   Blocking is the art of preventing forward progress in a program.

*** What is blocking?
    Blocking is an umbrella for thread states that aren't ~Runnable~, meaning that there exists some condition preventing forward progress. 3 such states:
    - Waiting
    - Timed Waiting
    - Blocking (special condition, because the JVM is special)

*** What does blocking cost?
    - Interaction with synchronization primitives
    - Context switches

    #+BEGIN_SRC scala
      import java.time.Duration
      type Task = () => Unit
      implicit def TaskToRunnable(t: Task): Runnable = new Runnable {
        override def run(): Unit = t()
      }

      val fast: Task = () => { var i = 0;
        while(i < 1000000) {
          i += 1
        }
      }

      val cooperative: Task = () => { var i = 0;
        while(i < 1000000) {
          i += 1
          Thread.`yield`()
        }
      }

      val mon = new Object
      val synced: Task = () => { var i = 0;
        while(i < 1000000) {
          mon.synchronized {
            i += 1
          }
        }
      }

      def timed(work: => Unit): Duration = {
        val start = System.nanoTime
        work
        val diff = System.nanoTime - start
        Duration.ofNanos(diff)
      }

      def syncs(count: Int): Unit = {
        val threads = 1 to count map { _ => new Thread(synced.apply _) }
        threads.foreach { _.start() }
        threads.foreach { _.join() }
      }

      // with some lock contention
      1 to 10 map { c => timed(syncs(c)) }
    #+END_SRC

*** How to block
    - ~foo.synchronized { foo.wait() }~
    - Things in ~java.util.concurrent.locks.LockSupport~
    - Locks available in ~java.util.concurrent.Locks~

*** How to interact with blocked things
    - ~Thread.getState~
    - ~foo.synchronized { foo.notify() | foo.notifyAll() }~

*** "All code is blocking" -Dave

    False.

    Threads make progress or they don't. Progress is good. Being blocked isn't.

** Locks
   Higher-level abstractions built on synchronization primitives and platform-support

*** What is a lock?
    A lock provides synchronized access control to /something/

    #+BEGIN_SRC scala :results silent
      // lifted directly from javadoc of Lock
      import java.util.concurrent.locks.ReentrantLock
      val l = new ReentrantLock()
      l.lock() //blocks until it locks
      try {
        // access resource protected by this lock
      } finally {
        l.unlock()
      }
    #+END_SRC

*** What costs are involved?
    Interaction with synchronization primitives and some method calls.
    
*** How to make a lock
    Use synchronization primitives or built-in locking in ~java.util.concurrent.locks~

    #+BEGIN_SRC scala :results silent
      import java.util.concurrent.locks.ReentrantLock

      class Locked[T](initialValue: T) {
        private[this] val lock = new ReentrantLock()

        private[this] var value: T = initialValue

        def read(): T = {
          lock.lock()
          try { value } finally { lock.unlock() }
        }

        def update(modifier: T => T): Unit = {
          lock.lock()
          try {
            value = modifier(value)     
          } finally lock.unlock()
        }
      }
    #+END_SRC

*** How to interact with a lock
    

*** Alternatives
    - Compare-and-Swap (CAS)
    - ~java.util.concurrent.atomic._~
    - Sequential access keyword: ~volatile~
